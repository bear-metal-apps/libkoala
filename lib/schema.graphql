schema {
  query: Query
  mutation: Mutation
}

interface IScoreBreakdown {
  year: Int!
}

type AllianceScoreBreakdown2015 {
  containerPoints: Int!
  totePoints: Int!
  litterPoints: Int!
  toteCountFar: Int!
  toteCountNear: Int!
  toteSet: Boolean!
  toteStack: Boolean!
  containerCountLevel1: Int!
  containerCountLevel2: Int!
  containerCountLevel3: Int!
  containerCountLevel4: Int!
  containerCountLevel5: Int!
  containerCountLevel6: Int!
  containerSet: Boolean!
  litterCountContainer: Int!
  litterCountLandfill: Int!
  litterCountUnprocessed: Int!
  robotSet: Boolean!
  autoPoints: Int!
  teleopPoints: Int!
  foulPoints: Int!
  adjustPoints: Int!
  totalPoints: Int!
  foulCount: Int!
}

type AllianceScoreBreakdown2025 {
  algaePoints: Int!
  autoBonusAchieved: Boolean!
  autoCoralCount: Int!
  autoCoralPoints: Int!
  autoLineRobot1: String
  autoLineRobot2: String
  autoLineRobot3: String
  autoMobilityPoints: Int!
  autoReef: Reef
  bargeBonusAchieved: Boolean!
  coopertitionCriteriaMet: Boolean!
  coralBonusAchieved: Boolean!
  endGameBargePoints: Int!
  endGameRobot1: String
  endGameRobot2: String
  endGameRobot3: String
  g206Penalty: Boolean!
  g410Penalty: Boolean!
  g418Penalty: Boolean!
  g428Penalty: Boolean!
  netAlgaeCount: Int!
  rankingPoints: Int!
  techFoulCount: Int!
  teleopCoralCount: Int!
  teleopCoralPoints: Int!
  teleopReef: Reef
  wallAlgaeCount: Int!
  autoPoints: Int!
  teleopPoints: Int!
  foulPoints: Int!
  adjustPoints: Int!
  totalPoints: Int!
  foulCount: Int!
}

type District {
  abbreviation: String!
  displayName: String!
  key: String!
  year: Int!
}

type MatchVideo {
  type: String!
  key: String!
}

type Mutation {
  updateUser(id: String!, user: UserInput!): User! @cost(weight: "10")
}

type Query {
  team(teamKey: String!): TBATeam! @cost(weight: "10")
  event(eventKey: String!): TBAEvent! @cost(weight: "10")
  match(matchKey: String!): TBAMatch! @cost(weight: "10")
  eventTeams(eventKey: String!): [TBATeam!]! @cost(weight: "10")
  eventMatches(eventKey: String!): [TBAMatch!]! @cost(weight: "10")
}

type Reef {
  botRow: ReefRow!
  midRow: ReefRow!
  topRow: ReefRow!
  trough: Int!
  tbaBotRowCount: Int!
  tbaMidRowCount: Int!
  tbaTopRowCount: Int!
}

type ReefRow {
  nodeA: Boolean!
  nodeB: Boolean!
  nodeC: Boolean!
  nodeD: Boolean!
  nodeE: Boolean!
  nodeF: Boolean!
  nodeG: Boolean!
  nodeH: Boolean!
  nodeI: Boolean!
  nodeJ: Boolean!
  nodeK: Boolean!
  nodeL: Boolean!
}

type ScoreBreakdown2015 implements IScoreBreakdown {
  year: Int!
  blue: AllianceScoreBreakdown2015!
  red: AllianceScoreBreakdown2015!
  coopertition: String
  coopertitionPoints: Int
}

type ScoreBreakdown2025 implements IScoreBreakdown {
  year: Int!
  blue: AllianceScoreBreakdown2025!
  red: AllianceScoreBreakdown2025!
  coopertition: String
  coopertitionPoints: Int
}

type TBAAlliance {
  score: Int!
  teamKeys: [String!]!
  surrogateTeamKeys: [String!]
  dqTeamKeys: [String!]
}

type TBAEvent {
  key: String!
  name: String!
  eventCode: String!
  eventType: Int!
  district: District
  city: String
  stateProv: String
  country: String
  startDate: DateTime!
  endDate: DateTime!
  year: Int!
  shortName: String
  eventTypeString: String!
  week: Int
  address: String
  postalCode: String
  gmapsPlaceId: String
  gmapsUrl: String
  lat: Float
  lng: Float
  locationName: String
  timezone: String
  website: String
  firstEventId: String
  firstEventCode: String
  webcasts: [Webcast!]
  divisionKeys: [String!]
  parentEventKey: String
  playoffType: Int
  playoffTypeString: String
}

type TBAMatch {
  key: String!
  compLevel: String!
  setNumber: Int!
  matchNumber: Int!
  alliances: TBAMatchAlliances
  winningAlliance: String
  eventKey: String!
  time: Long
  actualTime: Long
  predictedTime: Long
  postResultTime: Long
  scoreBreakdown: IScoreBreakdown
  videos: [MatchVideo!]
}

type TBAMatchAlliances {
  red: TBAAlliance!
  blue: TBAAlliance!
}

type TBATeam {
  key: String!
  teamNumber: Int!
  nickname: String!
  name: String!
  schoolName: String
  city: String
  stateProv: String
  country: String
  address: String
  postalCode: String
  gmapsPlaceId: String
  gmapsUrl: String
  lat: Float
  lng: Float
  locationName: String
  website: String
  rookieYear: Int
}

type User {
  id: String!
  firstName: String!
  lastName: String!
  email: String!
  createdAt: DateTime!
  updatedAt: DateTime
  lastLoginAt: DateTime
  preferences: UserPreferences!
  roles: [Role!]!
}

type UserPreferences {
  theme: Theme!
  "Hex code for the theme color"
  themeColor: String!
}

type Webcast {
  type: String!
  channel: String
  date: String
  file: String
}

input UserInput {
  id: String!
  firstName: String!
  lastName: String!
  email: String!
  createdAt: DateTime!
  updatedAt: DateTime
  lastLoginAt: DateTime
  preferences: UserPreferencesInput!
  roles: [Role!]!
}

input UserPreferencesInput {
  theme: Theme!
  "Hex code for the theme color"
  themeColor: String!
}

enum Role {
  "Edit roles for other users"
  MANAGE_ROLES
  "Create, edit, and view any picklist"
  MANAGE_PICKLISTS
  "View all notes on teams"
  VIEW_NOTES
  "Access drive team features (prematch strategy and note taking)"
  DRIVE_TEAM
  "Access strategist features (prematch strategy and sending notes to drive team)"
  STRATEGIST
  "Being able to scout matches and pits"
  SCOUT
}

enum Theme {
  LIGHT
  DARK
  SYSTEM
}

"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost(
  "The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc."
  weight: String!
) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy(
  "The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types."
  url: String!
) on SCALAR

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https://www.graphql-scalars.com/date-time")

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long
